# 遊戲開發 - GPU 狀態管理與數據上傳

在前兩篇中，我們討論了 GPU 繪圖管線和 Shader 程式。本篇將深入探討如何操作 GPU 狀態以及如何上傳數據資料進行渲染，這些是實際開發 3D 圖形應用時的核心概念。

## GPU 狀態機 (State Machine)

GPU 本質上是一個龐大的狀態機，各種繪圖操作都依賴於 GPU 的當前狀態。理解並有效管理這些狀態是高效渲染的關鍵。

### 核心 GPU 狀態

1. **渲染狀態 (Rendering State)**
   - **剔除模式 (Culling Mode)**：決定哪些三角形面需要繪製。通常背面剔除（只渲染面向觀察者的三角形）可節省約一半的片段處理工作。
   - **深度測試 (Depth Test)**：確定像素的可見性，解決物體的遮擋關係。
   - **混合模式 (Blending)**：控制像素顏色如何與已存在的幀緩衝區值混合，實現透明效果。
   - **模板測試 (Stencil Test)**：實現蒙版效果，可用於鏡面反射、陰影體積等複雜效果。

2. **著色器狀態 (Shader State)**
   - **著色器程序**：當前綁定的頂點、片段等著色器。
   - **Uniform 變數**：傳遞給著色器的全局數據（如變換矩陣、光照參數）。
   - **採樣器綁定**：控制紋理查詢的過濾和尋址模式。

3. **資源綁定狀態 (Resource Binding State)**
   - **頂點緩衝區**：包含頂點數據（位置、法線、UV 等）。
   - **索引緩衝區**：定義三角形的頂點連接順序。
   - **紋理單元**：渲染時使用的紋理資源。
   - **渲染目標**：繪製結果的輸出位置（幀緩衝區、紋理等）。

### 狀態切換成本

GPU 狀態的改變是有成本的。頻繁切換狀態會導致性能下降，這是因為：

1. **流水線刷新 (Pipeline Flush)**：某些狀態更改需要清空 GPU 處理管線，等待所有進行中的操作完成。
2. **驅動驗證 (Driver Validation)**：每次狀態改變，驅動需要驗證新狀態的有效性，確保組合合理。
3. **緩存失效 (Cache Invalidation)**：狀態變更可能導致 GPU 內部緩存無效，失去硬體快取加速優勢。

高效的渲染系統會盡量減少狀態切換次數。這通常通過按狀態對渲染對象進行排序來實現，將使用相同著色器、紋理和渲染狀態的對象分組渲染。

## 數據上傳與緩衝區管理

GPU 需要大量數據才能進行渲染。這些數據必須從 CPU 記憶體上傳到 GPU 顯存，這個過程是渲染管線中的一個潛在瓶頸。

### 主要緩衝區類型

1. **頂點緩衝區 (Vertex Buffer Objects, VBOs)**
   - 存儲頂點數據：位置、法線、UV 坐標等
   - 結構化數據，每個頂點包含多個屬性
   - 通常使用交錯格式存儲（每個頂點的所有屬性連續存放）以提高緩存命中率

2. **索引緩衝區 (Index Buffer Objects, IBOs)**
   - 存儲頂點索引，定義三角形的連接方式
   - 通過重用頂點減少內存使用和頻寬需求
   - 典型的三角形網格可節省 50-80% 的頂點數據

3. **Uniform 緩衝區 (Uniform Buffer Objects, UBOs)**
   - 存儲著色器程序使用的全局變量（如變換矩陣、光照參數）
   - 可在多個繪製調用間共享，減少 CPU-GPU 通信
   - 支持部分更新，無需每次更新整個緩衝區

4. **紋理緩衝區 (Texture Buffers)**
   - 存儲圖像數據，支持 1D、2D、3D 和立方體等格式
   - 支持不同的格式、維度和過濾模式
   - 可能是內存佔用最大的資源類型

### 數據上傳策略

數據上傳是 CPU 和 GPU 之間的橋樑，管理不當會導致性能問題：

1. **靜態數據 vs 動態數據**
   - **靜態數據**：載入時上傳一次，整個應用生命週期不變（如模型網格、紋理）
   - **動態數據**：每幀或頻繁更新（如變換矩陣、動畫數據）
   - 靜態和動態數據應使用不同的上傳策略和緩衝區類型

2. **數據更新方式**
   - **完全重寫**：適用於每幀完全改變的數據
   - **部分更新**：只更新變化的部分，減少數據傳輸量
   - **雙緩衝/三緩衝**：使用多個緩衝區交替使用，避免等待 GPU 完成前一幀的處理

3. **暫存緩衝區 (Staging Buffers)**
   - CPU 先寫入易於訪問的暫存區，再傳輸到 GPU 專用內存
   - 分離 CPU 寫入和 GPU 讀取操作，允許並行處理
   - 在現代 API (Vulkan, Direct3D 12, Metal) 中是標準做法

### 記憶體類型與訪問模式

不同的記憶體類型有不同的性能特性：

1. **GPU 專用記憶體 (Device Local)**: 最快的 GPU 訪問速度，但 CPU 難以直接訪問
2. **共享記憶體 (Shared/Upload)**：CPU 和 GPU 都可訪問，但對兩者都不是最佳選擇
3. **暫存記憶體 (Staging)**：適合 CPU 寫入，然後傳輸到 GPU 專用記憶體

選擇合適的記憶體類型和訪問模式對性能有顯著影響。

## 實際應用：狀態管理與批處理渲染

現代繪圖系統使用各種技術來最小化狀態切換並優化數據上傳：

### 批處理與排序 (Batching and Sorting)

1. **依狀態排序 (State Sorting)**
   - 按著色器、紋理、混合模式等對繪製命令排序
   - 最小化狀態切換次數
   - 排序策略通常考慮狀態切換成本（例如，更改著色器的成本高於更改紋理）

2. **合批 (Batching)**
   - 將使用相同材質的對象合併成批次
   - 減少繪製調用 (draw calls)，降低 CPU 開銷
   - 可靜態（預處理時合併網格）或動態（運行時合併繪製命令）實現

3. **實例化 (Instancing)**
   - 單次繪製調用渲染多個相同網格的實例
   - 每個實例使用不同的參數（位置、顏色等）
   - 適用於重複物體（如樹木、草地、粒子）

### 狀態緩存和複用 (State Caching and Reuse)

現代圖形 API 通常實現狀態物件的概念：

1. **Pipeline State Objects (PSOs)**
   - 封裝完整的渲染管線配置（著色器、混合模式、深度測試等）
   - 預編譯和優化，減少運行時狀態驗證
   - 允許 GPU 驅動預先分析和優化管線配置

2. **狀態緩存 (State Caching)**
   - 跟踪當前 GPU 狀態，避免冗餘設置
   - 僅在必要時更改狀態
   - 可在應用層或驅動層實現

3. **命令緩衝區 (Command Buffers)**
   - 預先記錄繪製命令序列
   - 支持並行構建和提交
   - 可重用於多個幀，減少 CPU 開銷

## 現代 API 中的狀態管理 (Vulkan, Direct3D 12, Metal)

現代低級圖形 API 完全改變了狀態管理和數據上傳的方式：

1. **顯式狀態管理 (Explicit State Management)**
   - 開發者負責跟踪和管理所有 GPU 狀態
   - 沒有隱式狀態恢復或驗證
   - 提供更高的可預測性和性能，但增加了程式複雜度

2. **命令列表與隊列 (Command Lists and Queues)**
   - 在 CPU 上構建命令列表，然後一次性提交給 GPU
   - 支持多線程記錄，充分利用多核 CPU
   - 命令列表可以預先記錄和重用，減少 CPU 開銷

3. **資源屏障 (Resource Barriers)**
   - 明確指定資源的狀態轉換（如從「紋理」到「渲染目標」）
   - 管理資源的讀/寫依賴
   - 讓 GPU 能夠優化內存訪問和同步

4. **描述符集 (Descriptor Sets)**
   - 預先配置資源綁定（紋理、緩衝區等）
   - 快速切換整組資源
   - 減少逐個資源綁定的開銷

### 多線程渲染 (Multithreaded Rendering)

現代 API 專為多線程設計：

1. **資源創建與上傳**：可在後台線程進行
2. **命令記錄**：可在多個線程同時構建命令列表
3. **狀態管理**：不同線程可處理場景的不同部分

這種並行性可顯著提高 CPU 利用率，減少繪製準備時間。

## 總結

有效的 GPU 狀態管理和數據上傳策略對於實現高性能圖形應用至關重要：

1. **理解 GPU 狀態機**
   - 了解不同狀態的影響和成本
   - 最小化狀態切換
   - 選擇合適的渲染順序

2. **優化數據傳輸**
   - 批量上傳數據
   - 區分靜態和動態資源
   - 使用適當的緩衝區更新策略
   - 選擇最佳的記憶體類型

3. **先進技術**
   - 實現批處理和排序
   - 使用實例化減少繪製調用
   - 採用現代 API 的顯式狀態管理
   - 利用多線程構建渲染命令

透過掌握這些概念和技術，開發者可以顯著提高圖形應用的性能和效率，實現更高質量的視覺效果和更流暢的用戶體驗。

# 參考延伸閱讀

[GPU Driven Rendering](https://vkguide.dev/docs/gpudriven/gpu_driven_rendering/)

[Understanding Modern Graphics API](https://alain.xyz/blog/comparison-of-modern-graphics-apis)

[GPU Performance for Game Artists](https://www.unrealengine.com/en-US/blog/gpu-performance-for-game-artists)
